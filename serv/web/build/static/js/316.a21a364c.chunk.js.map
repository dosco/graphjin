{"version":3,"file":"static/js/316.a21a364c.chunk.js","mappings":"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","sources":["../node_modules/codemirror-graphql/src/utils/forEachState.ts","../node_modules/codemirror-graphql/src/utils/hintList.ts","../node_modules/codemirror-graphql/src/variables/hint.ts"],"sourcesContent":["/**\n *  Copyright (c) 2021 GraphQL Contributors\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\nimport type { State, Maybe } from 'graphql-language-service';\n\n// Utility for iterating through a CodeMirror parse state stack bottom-up.\nexport default function forEachState(stack: State, fn: (state: State) => void) {\n  const reverseStateStack = [];\n  let state: Maybe<State> = stack;\n  while (state && state.kind) {\n    reverseStateStack.push(state);\n    state = state.prevState;\n  }\n  for (let i = reverseStateStack.length - 1; i >= 0; i--) {\n    fn(reverseStateStack[i]);\n  }\n}\n","/**\n *  Copyright (c) 2021 GraphQL Contributors\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\nimport type CodeMirror from 'codemirror';\nimport { IHint, IHints } from 'src/hint';\n\n// Create the expected hint response given a possible list and a token\nexport default function hintList(\n  cursor: CodeMirror.Position,\n  token: CodeMirror.Token,\n  list: IHint[],\n): IHints | undefined {\n  const hints = filterAndSortList(list, normalizeText(token.string));\n  if (!hints) {\n    return;\n  }\n\n  const tokenStart =\n    token.type !== null && /\"|\\w/.test(token.string[0])\n      ? token.start\n      : token.end;\n\n  return {\n    list: hints,\n    from: { line: cursor.line, ch: tokenStart }, // TODO: Confirm. Was changed column to ch\n    to: { line: cursor.line, ch: token.end },\n  };\n}\n\n// Given a list of hint entries and currently typed text, sort and filter to\n// provide a concise list.\nfunction filterAndSortList(list: IHint[], text: string) {\n  if (!text) {\n    return filterNonEmpty(list, entry => !entry.isDeprecated);\n  }\n\n  const byProximity = list.map(entry => ({\n    proximity: getProximity(normalizeText(entry.text), text),\n    entry,\n  }));\n\n  const conciseMatches = filterNonEmpty(\n    filterNonEmpty(byProximity, pair => pair.proximity <= 2),\n    pair => !pair.entry.isDeprecated,\n  );\n\n  const sortedMatches = conciseMatches.sort(\n    (a, b) =>\n      (a.entry.isDeprecated ? 1 : 0) - (b.entry.isDeprecated ? 1 : 0) ||\n      a.proximity - b.proximity ||\n      a.entry.text.length - b.entry.text.length,\n  );\n\n  return sortedMatches.map(pair => pair.entry);\n}\n\n// Filters the array by the predicate, unless it results in an empty array,\n// in which case return the original array.\nfunction filterNonEmpty<T>(array: T[], predicate: (item: T) => boolean) {\n  const filtered = array.filter(predicate);\n  return filtered.length === 0 ? array : filtered;\n}\n\nfunction normalizeText(text: string) {\n  return text.toLowerCase().replace(/\\W/g, '');\n}\n\n// Determine a numeric proximity for a suggestion based on current text.\nfunction getProximity(suggestion: string, text: string) {\n  // start with lexical distance\n  let proximity = lexicalDistance(text, suggestion);\n  if (suggestion.length > text.length) {\n    // do not penalize long suggestions.\n    proximity -= suggestion.length - text.length - 1;\n    // penalize suggestions not starting with this phrase\n    proximity += suggestion.indexOf(text) === 0 ? 0 : 0.5;\n  }\n  return proximity;\n}\n\n/**\n * Computes the lexical distance between strings A and B.\n *\n * The \"distance\" between two strings is given by counting the minimum number\n * of edits needed to transform string A into string B. An edit can be an\n * insertion, deletion, or substitution of a single character, or a swap of two\n * adjacent characters.\n *\n * This distance can be useful for detecting typos in input or sorting\n *\n * @param {string} a\n * @param {string} b\n * @return {int} distance in number of edits\n */\nfunction lexicalDistance(a: string, b: string) {\n  let i;\n  let j;\n  const d = [];\n  const aLength = a.length;\n  const bLength = b.length;\n\n  for (i = 0; i <= aLength; i++) {\n    d[i] = [i];\n  }\n\n  for (j = 1; j <= bLength; j++) {\n    d[0][j] = j;\n  }\n\n  for (i = 1; i <= aLength; i++) {\n    for (j = 1; j <= bLength; j++) {\n      const cost = a[i - 1] === b[j - 1] ? 0 : 1;\n\n      d[i][j] = Math.min(\n        d[i - 1][j] + 1,\n        d[i][j - 1] + 1,\n        d[i - 1][j - 1] + cost,\n      );\n\n      if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {\n        d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + cost);\n      }\n    }\n  }\n\n  return d[aLength][bLength];\n}\n","/**\n *  Copyright (c) 2021 GraphQL Contributors\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\nimport CodeMirror, { Hints } from 'codemirror';\nimport {\n  getNullableType,\n  getNamedType,\n  GraphQLEnumType,\n  GraphQLInputObjectType,\n  GraphQLList,\n  GraphQLBoolean,\n  GraphQLInputType,\n  GraphQLInputFieldMap,\n} from 'graphql';\nimport type { State, Maybe } from 'graphql-language-service';\nimport { IHints } from 'src/hint';\n\nimport forEachState from '../utils/forEachState';\nimport hintList from '../utils/hintList';\n\nexport type VariableToType = Record<string, GraphQLInputType>;\ninterface GraphQLVariableHintOptions {\n  variableToType: VariableToType;\n}\n\ndeclare module 'codemirror' {\n  interface ShowHintOptions {\n    variableToType?: VariableToType;\n  }\n\n  interface CodeMirrorHintMap {\n    'graphql-variables': (\n      editor: CodeMirror.Editor,\n      options: GraphQLVariableHintOptions,\n    ) => IHints | undefined;\n  }\n}\n\n/**\n * Registers a \"hint\" helper for CodeMirror.\n *\n * Using CodeMirror's \"hint\" addon: https://codemirror.net/demo/complete.html\n * Given an editor, this helper will take the token at the cursor and return a\n * list of suggested tokens.\n *\n * Options:\n *\n *   - variableToType: { [variable: string]: GraphQLInputType }\n *\n * Additional Events:\n *\n *   - hasCompletion (codemirror, data, token) - signaled when the hinter has a\n *     new list of completion suggestions.\n *\n */\nCodeMirror.registerHelper(\n  'hint',\n  'graphql-variables',\n  (\n    editor: CodeMirror.Editor,\n    options: GraphQLVariableHintOptions,\n  ): Hints | undefined => {\n    const cur = editor.getCursor();\n    const token = editor.getTokenAt(cur);\n\n    const results = getVariablesHint(cur, token, options);\n    if (results && results.list && results.list.length > 0) {\n      results.from = CodeMirror.Pos(results.from.line, results.from.ch);\n      results.to = CodeMirror.Pos(results.to.line, results.to.ch);\n      CodeMirror.signal(editor, 'hasCompletion', editor, results, token);\n    }\n\n    return results;\n  },\n);\n\nfunction getVariablesHint(\n  cur: CodeMirror.Position,\n  token: CodeMirror.Token,\n  options: GraphQLVariableHintOptions,\n) {\n  // If currently parsing an invalid state, attempt to hint to the prior state.\n  const state =\n    token.state.kind === 'Invalid' ? token.state.prevState : token.state;\n\n  const kind = state.kind;\n  const step = state.step;\n\n  // Variables can only be an object literal.\n  if (kind === 'Document' && step === 0) {\n    return hintList(cur, token, [{ text: '{' }]);\n  }\n\n  const variableToType = options.variableToType;\n  if (!variableToType) {\n    return;\n  }\n\n  const typeInfo = getTypeInfo(variableToType, token.state);\n\n  // Top level should typeahead possible variables.\n  if (kind === 'Document' || (kind === 'Variable' && step === 0)) {\n    const variableNames = Object.keys(variableToType);\n    return hintList(\n      cur,\n      token,\n      variableNames.map(name => ({\n        text: `\"${name}\": `,\n        type: variableToType[name],\n      })),\n    );\n  }\n\n  // Input Object fields\n  if (kind === 'ObjectValue' || (kind === 'ObjectField' && step === 0)) {\n    if (typeInfo.fields) {\n      const inputFields = Object.keys(typeInfo.fields).map(\n        fieldName => typeInfo.fields![fieldName],\n      );\n      return hintList(\n        cur,\n        token,\n        inputFields.map(field => ({\n          text: `\"${field.name}\": `,\n          type: field.type,\n          description: field.description,\n        })),\n      );\n    }\n  }\n\n  // Input values.\n  if (\n    kind === 'StringValue' ||\n    kind === 'NumberValue' ||\n    kind === 'BooleanValue' ||\n    kind === 'NullValue' ||\n    (kind === 'ListValue' && step === 1) ||\n    (kind === 'ObjectField' && step === 2) ||\n    (kind === 'Variable' && step === 2)\n  ) {\n    const namedInputType = typeInfo.type\n      ? getNamedType(typeInfo.type)\n      : undefined;\n    if (namedInputType instanceof GraphQLInputObjectType) {\n      return hintList(cur, token, [{ text: '{' }]);\n    } else if (namedInputType instanceof GraphQLEnumType) {\n      const values = namedInputType.getValues();\n      // const values = Object.keys(valueMap).map(name => valueMap[name]); // TODO: Previously added\n      return hintList(\n        cur,\n        token,\n        values.map(value => ({\n          text: `\"${value.name}\"`,\n          type: namedInputType,\n          description: value.description,\n        })),\n      );\n    } else if (namedInputType === GraphQLBoolean) {\n      return hintList(cur, token, [\n        { text: 'true', type: GraphQLBoolean, description: 'Not false.' }, // TODO: type and description don't seem to be used. Added them as optional anyway.\n        { text: 'false', type: GraphQLBoolean, description: 'Not true.' },\n      ]);\n    }\n  }\n}\ninterface VariableTypeInfo {\n  type?: Maybe<GraphQLInputType>;\n  fields?: Maybe<GraphQLInputFieldMap>;\n}\n// Utility for collecting rich type information given any token's state\n// from the graphql-variables-mode parser.\nfunction getTypeInfo(\n  variableToType: Record<string, GraphQLInputType>,\n  tokenState: State,\n) {\n  const info: VariableTypeInfo = {\n    type: null,\n    fields: null,\n  };\n\n  forEachState(tokenState, state => {\n    if (state.kind === 'Variable') {\n      info.type = variableToType[state.name!];\n    } else if (state.kind === 'ListValue') {\n      const nullableType = info.type ? getNullableType(info.type) : undefined;\n      info.type =\n        nullableType instanceof GraphQLList ? nullableType.ofType : null;\n    } else if (state.kind === 'ObjectValue') {\n      const objectType = info.type ? getNamedType(info.type) : undefined;\n      info.fields =\n        objectType instanceof GraphQLInputObjectType\n          ? objectType.getFields()\n          : null;\n    } else if (state.kind === 'ObjectField') {\n      const objectField =\n        state.name && info.fields ? info.fields[state.name] : null;\n      info.type = objectField && objectField.type;\n    }\n  });\n\n  return info;\n}\n"],"names":["exports","stack","fn","reverseStateStack","state","kind","push","prevState","i","length","filterNonEmpty","array","predicate","filtered","filter","normalizeText","text","toLowerCase","replace","getProximity","suggestion","proximity","a","b","j","d","aLength","bLength","cost","Math","min","lexicalDistance","indexOf","cursor","token","list","hints","entry","isDeprecated","map","pair","sort","filterAndSortList","string","tokenStart","type","test","start","end","from","line","ch","to","codemirror_1","registerHelper","editor","options","cur","getCursor","getTokenAt","results","step","hintList_1","variableToType","typeInfo","tokenState","info","fields","forEachState_1","name","nullableType","graphql_1","undefined","ofType","objectType","getFields","objectField","getTypeInfo","variableNames","Object","keys","inputFields","fieldName","field","description","namedInputType_1","values","getValues","value","getVariablesHint","Pos","signal"],"sourceRoot":""}